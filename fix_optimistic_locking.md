# Исправление проблемы ObjectOptimisticLockingFailureException

## Проблема

При выполнении теста `IsolationsTest.showDifference()` возникает исключение:

```
org.springframework.orm.ObjectOptimisticLockingFailureException: Row was already updated or deleted by another transaction for entity [ru.mentee.power.crm.spring.entity.Lead with id 'f6b0897e-a0bf-42b8-a53e-3de98b114c9b']
```

Это происходит из-за конфликта версий при попытке одновременного обновления одной и той же сущности `Lead` в разных транзакциях. Hibernate не может определить, какая версия данных должна быть сохранена, что приводит к `StaleObjectStateException`.

## Причина

Проблема заключается в отсутствии поддержки оптимистичной блокировки в сущности `Lead`. В Hibernate оптимистичная блокировка реализуется с помощью аннотации `@Version`, которая:

1. Отслеживает версию сущности
2. Автоматически увеличивает версию при каждом обновлении
3. Проверяет версию при сохранении, чтобы убедиться, что объект не был изменён другой транзакцией

Без поля `@Version` Hibernate не может безопасно обрабатывать параллельные обновления, что приводит к конфликтам.

## Решение

Было добавлено поле `version` в сущность `Lead` с аннотацией `@Version`:

```java
@Version
private Long version;
```

Это поле будет автоматически управляться Hibernate для поддержки оптимистичной блокировки.

## Как это работает

1. При первом сохранении сущности `version` устанавливается в 0
2. При каждом обновлении `version` автоматически увеличивается на 1
3. При попытке обновления Hibernate проверяет, что версия в базе данных совпадает с версией в объекте
4. Если версии не совпадают (объект был изменён другой транзакцией), выбрасывается `ObjectOptimisticLockingFailureException`

## Рекомендации

1. Всегда используйте `@Version` в сущностях, которые могут обновляться параллельно
2. Обрабатывайте `ObjectOptimisticLockingFailureException` в бизнес-логике, например, путём повторной попытки операции
3. Рассмотрите возможность использования пессимистичной блокировки для высококонкурентных сценариев
4. Убедитесь, что все обновления сущностей проходят через менеджер сущностей Hibernate

## Проверка

После внесения изменений тест `IsolationsTest.showDifference()` должен проходить успешно, так как Hibernate теперь может корректно обрабатывать параллельные транзакции с помощью оптимистичной блокировки.